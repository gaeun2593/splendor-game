# 💎 Splendor 게임 온라인 구현 프로젝트 (Splendor Game Online Implementation)

본 프로젝트는 인기 보드 게임인 스플렌더(Splendor)를 웹소켓 기반의 실시간 멀티플레이어 환경에서 즐길 수 있도록 Spring Boot와 Redis를 활용하여 구현한 백엔드 애플리케이션입니다.

---

## 🚀 주요 기능 (Features)

* **실시간 방/게임 관리:** WebSocket (STOMP)을 이용한 실시간 방 생성, 입장, 준비 상태 및 게임 시작 관리 기능을 제공합니다.
* **게임 상태 동기화:** **Redis**를 활용하여 게임 보드 상태, 플레이어 토큰/카드 보유 현황, 현재 턴 등을 실시간으로 관리하고 동기화합니다. (`GameStateDto`를 Redis에 저장)
* **턴 기반 액션 처리:** 세 가지 주요 액션(`PlayerAction.java`) 중 **토큰 획득** 및 **카드 구매**에 대한 요청 및 유효성 검증 로직을 구현했습니다.
    * **토큰 획득 유효성 검증:** 서로 다른 3개 또는 같은 보석 2개 획득 (잔여 토큰 4개 이상 조건 포함) 규칙을 검증합니다. (`TokenAcquisitionValidator.java`)
    * **개발 카드 구매 로직:** 보유 토큰 및 보너스를 사용한 카드 구매 및 비용 지불 로직을 처리합니다. (`PlayerStateCalculator.java`)
    * **토큰 버리기:** 10개 초과 토큰 보유 시 토큰을 버리고 보드로 회수하는 기능을 제공합니다.
* **승리 조건 처리:** 15점 이상 달성 시 최종 라운드 진행 및 복잡한 **동점 승리 조건** 로직을 구현했습니다. (`PlayGameService.determineWinner`)

---

## 🛠️ 기술 스택 (Tech Stack)

| 카테고리 | 기술 | 용도 |
| :--- | :--- | :--- |
| **백엔드** | Java 21 | 메인 애플리케이션 언어 |
| **프레임워크** | Spring Boot 3.x | 웹/백엔드 핵심 프레임워크 |
| **실시간 통신** | WebSocket (STOMP) | 게임 내 실시간 턴 액션 및 상태 업데이트 |
| **상태 관리** | Redis | `GameState` 등 휘발성 게임 상태의 실시간 저장 및 관리 |
| **영속성** | Spring Data JPA, H2 | 정적 데이터(카드, 귀족), 방 및 플레이어 정보 저장 |
| **인증** | JJWT | 플레이어 인증 및 인가 처리 |

---

## 📜 게임 규칙 상세 (Implemented Game Rules)

본 프로젝트에 반영된 주요 게임 규칙은 다음과 같습니다.

### 1. 초기 세팅 (Setup)

| 플레이어 수 | 일반 보석 토큰 (각 종류별) | 황금 토큰 (GOLD) |
| :--- | :--- | :--- |
| 2인 | 4개 | 5개 |
| 3인 | 5개 | 5개 |
| 4인 | 7개 | 5개 |

* 각 단계별 개발 카드 4장씩 오픈.
* 귀족 타일은 플레이어 수 + 1장 임의로 뽑아 펼쳐 놓습니다. (귀족 타일: 총 10개 구성)

### 2. 플레이어 턴 행동 (Player Actions)

플레이어는 턴마다 다음 세 가지 행동 중 **하나**만 수행할 수 있습니다.

#### ① 보석 토큰 획득 (TAKE_TOKENS)
* **서로 다른 3가지** 보석 토큰을 1개씩 가져옵니다.
* **같은 종류 보석 2개**를 가져올 수 있습니다. (단, 해당 보석이 보드에 **4개 이상** 남아있어야 합니다.)
* **토큰 제한:** 플레이어는 최대 **10개**의 토큰을 소지할 수 있으며, 초과 시 초과분만큼 즉시 버려야 합니다.

#### ② 개발 카드 구매 (BUY_CARD)
* 보유 토큰 및 구매한 개발 카드의 보석 보너스(할인)를 사용하여 바닥에 놓인 카드를 구매합니다.
* **황금 토큰**은 부족한 모든 종류의 보석을 대체하여 사용할 수 있습니다.

#### ③ 개발 카드 예약 (RESERVE_CARD)
* **현재 미구현된 기능입니다.** (원래 기능: 카드 1장을 보관하고 황금 토큰 1개를 받습니다.)

#### 귀족 타일 획득
* 개발 카드의 보너스 수가 귀족 타일의 조건을 만족하면 **즉시** 획득합니다 (행동 소모 없음).
* 규칙에 따라 귀족 타일 획득은 **턴을 소모하는 행동으로 간주하지 않습니다.**

### 3. 게임 종료 및 승리 조건 (Game End & Victory)

#### 게임 종료 (End Condition)
어떤 플레이어든 **15점 이상**을 달성하면 **최종 라운드**가 시작되며, 해당 라운드의 마지막 플레이어까지 턴을 마친 후 게임이 종료됩니다.

#### 승리 조건 (Tie-breaker Logic)
라운드 종료 후, 점수가 동일할 경우 다음의 순위대로 승자를 결정합니다.

| 순위 | 조건 | 설명 (우선순위 높음 → 낮음) |
| :--- | :--- | :--- |
| **1순위** | 총 점수 | 점수가 가장 높은 플레이어 승리 |
| **2순위** | 개발 카드의 수 | 개발 카드의 수가 **더 적은** 플레이어가 승리 |
| **3순위** | 귀족 타일의 수 | 귀족 카드를 **더 많이** 가지고 있는 플레이어의 승리 |
| **4순위** | 남은 보석 토큰의 수 | 남은 보석 토큰의 수가 **더 많은** 플레이어의 승리 |
| **최종** | 턴 순서 | 모든 조건이 같을 경우, **후공** 플레이어의 승리 (턴 순서 인덱스가 더 큰 플레이어) |

---

## ⚠️ 미구현 사항 및 향후 계획 (To Do)

* **카드 예약 (Reserve Card) 기능 구현:** 황금 토큰 획득 및 최대 3장 보관, 보관된 카드 구매 로직을 추가해야 합니다.
* **보드 카드 보충 로직 구현:** 카드가 구매된 후, 해당 레벨의 덱에서 새로운 카드를 뽑아 보충하는 로직을 완성해야 합니다. (현재 `PlayGameService.updateBoardStateAfterPurchase`에 TODO 주석으로 남아있습니다.)
* **귀족 타일 획득 커밋:** 귀족 타일 획득 조건을 확인하고 플레이어 상태(`nobleCount`)에 반영하는 로직을 추가해야 합니다.